# -*- coding: utf-8 -*-
"""КоротецкаяПМ18_1_Multiprocessing_ipynb_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14vrNLq8ZTNBCH7mr4pWwNq4bHU-nIoBi

## Лабораторная 3 Мультипроцессинг
### Коротецкая ПМ18-1
"""

# Commented out IPython magic to ensure Python compatibility.
# %%file rand_string_.py
# 
# import random
# import string
# 
# def rand_string(length, output):
#     """ Generates a random string of numbers, lower- and uppercase chars. """
#     rand_str = ''.join(random.choice(
#                         string.ascii_lowercase 
#                         + string.ascii_uppercase 
#                         + string.digits)
#                    for i in range(length))
#     output.put(rand_str)

### Загружаем необходимые библиотеки
import pandas as pd
import collections, functools, operator
import rand_string_
import multiprocessing as mp
import random
import string
import os

import multiprocessing as mp
import random
import string

random.seed(42)

# Define an output queue
output = mp.Queue()

processes = [mp.Process(target=rand_string_.rand_string, args=(5, output)) \
             for x in range(4)]

# Run processes
for p in processes:
    p.start()

# Exit the completed processes
for p in processes:
    p.join()

# Get process results from the output queue
results = [output.get() for p in processes]

print(results)

from google.colab import drive
drive.mount('/content/drive')

"""1) Подсчитать, сколько раз встречается каждая из русских букв в текстовом файле (заглавные и строчные символы не различаются). Применить функцию к файлу 'Tolstoy Lev. Voyna i mir. Kniga 1 - BooksCafe.Net.txt' """

def cntwords(path,output):
  f = open(path, encoding = 'windows-1251')
  tmp = f.read()
  leters = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
  c = collections.Counter()
  for word in tmp.lower():
    if word in leters:
      c[word] += 1
  output.put(c)
  return c

cntwords('/content/drive/MyDrive/Texts/Tolstoy Lev. Voyna i mir. Kniga 1 - BooksCafe.Net.txt',output)

"""2) Подсчитать, сколько раз встречается каждая из русских букв во всех  текстовых файлах, лежащих в папке 'text'. При реализации выделить фукнцию, которая суммирует результаты обработки отдельных файлов. Определить за каое время решается задача для всех файлов из папки 'text'."""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# c1 = collections.Counter()
# def sumcntwords(a):
#   path = "/content/drive/MyDrive/Texts"
#   os.chdir(path)
#   for file in os.listdir():
#     a+= cntwords(file,output)
#   print(a)
# 
# 
# sumcntwords(c1)

"""3) Решить задачу 2, распараллелив вычисления с помощью модуля multiprocessing. Для обарботки каждого файла создать свой собственный процес. Определить за каое время решается задача для всех файлов из папки 'text'."""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# 
# random.seed(42)
# 
# # Define an output queue
# output = mp.Queue()
# 
# processes = [mp.Process(target=cntwords, args=(file, output)) \
#              for file in os.listdir()]
# # Run processes
# for p in processes:
#     p.start()
# 
# # Exit the completed processes
# for p in processes:
#     p.join()
# 
# # Get process results from the output queue
# results = [output.get() for p in processes]
# cnt = collections.Counter()
# for i in results:
#   cnt +=i
# print(cnt)

"""4) Решить задачу 2, распараллелив вычисления с помощью модуля multiprocessing. Создать фиксированное количество процессов (равное количеству ядер на компьютере). При помощи очереди передать задачи процессам и при помощи другой очереди забрать от них ответы. Определить за каое время решается задача для всех файлов из папки 'text'."""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# 
# cnt = collections.Counter()
# for i in range(5):
#   processes = [mp.Process(target=cntwords, args=(os.listdir()[2*i+gpus], output)) \
#              for gpus in range(mp.cpu_count())]
#   for p in processes:
#     p.start()
# 
#   # Exit the completed processes
#   for p in processes:
#     p.join()
# 
#   # Get process results from the output queue
#   results = [output.get() for p in processes]
#   for i in results:
#     cnt +=i
# print(cnt)
#

"""5) Решить задачу 2, распараллелив вычисления с помощью модуля multiprocessing. Решить задачу при помощи Pool. Определить за каое время решается задача для всех файлов из папки 'text'."""

def cntwords2(path):
  f = open(path, encoding = 'windows-1251')
  tmp = f.read()
  leters = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
  c = collections.Counter()
  for word in tmp.lower():
    if word in leters:
      c[word] += 1
  return c

# Commented out IPython magic to ensure Python compatibility.
# %%time
# def main():
#     with mp.Pool() as p:
#         a = p.map(cntwords2, [file for file in os.listdir()])
#         result = dict(functools.reduce(operator.add,map(collections.Counter, a)))
#         print(result)
# if __name__=="__main__":
#     main()

"""6) Распараллелиьть задачу один при помощи Pool. Сравнить время параллельного и последовательного решения задачи. """

def cntwords3(letter):
  path = os.listdir()[-3]
  f = open(path, encoding = 'windows-1251')
  tmp = f.read()
  c = collections.Counter()
  for item in tmp.lower():
    if item == letter:
      c[item] += 1 
  f.close()
  return c

# Commented out IPython magic to ensure Python compatibility.
# %%time
# leters = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя'
# def main():
#     with mp.Pool() as p:
#         a = p.map(cntwords3, list(leters))
#         result = dict(functools.reduce(operator.add,map(collections.Counter, a)))
#         print(result)
# if __name__=="__main__":
#     main()

"""Общее время увеличилось на 0.21 секунд с 4.54 до 4.75 """