# -*- coding: utf-8 -*-
"""Коротецкая_DASK.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x23dmpijPq4SKw5pQn9Z3ZzE7sI3_9DF
"""

import os
import numpy as np
import h5py
import dask.array as da

"""1) Создать массив размерностью 1000 на n (n - кратно тысячам), заполненный нормально распределенными числами (матожидание 0.0, стандартное отклонение 1.0), и сохранить его в файле(ах) с расширением hdf5"""

def daskarr(n):
  d = np.random.rand(1000,n)
  x = da.from_array(d, chunks=(1000, n))
  return x


darr = daskarr(10)
darr_np = np.array(darr)
da.to_hdf5('da.hdf5', '/darr', darr)

"""Решить 2я способами: с помощью NumPy и с помощью Dask Array и сравнить время выполнения:

2.1) Считать массив из файла и загрузить в dask array, и преобразовать отдельно в numpy array

2.2) Найти и вывести на экран наименьший элемент в массиве.
"""

f=h5py.File('da.hdf5','r')
z = da.from_array(f['/darr'], chunks=(1,10))
z

z_np = np.array(z)

z_np

# Commented out IPython magic to ensure Python compatibility.
# %time 
np.min(z_np)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# darr.min().compute()

"""3) Сгенирировать нормально распределенный одномерный массив из 1000 элементов (вектор $a$). Найти ближайший к нему (в смысле $L2$) вектор-столбец из исходного массива (вектор $v_n$)."""

z = z.reshape(10000,1)

z_np = z_np.reshape((10000,1))
z_np.shape

# Commented out IPython magic to ensure Python compatibility.
# %%time 
# a = da.random.normal(0,1, (1000,1), chunks=(1000,1))
# a_np = np.array(a)
# x_l2 = [np.linalg.norm(a_np-z_np[i:1000+i]) for i in range(0,9000,1000)]
# x = np.min(x_l2)
# for i in range(0,9000,1000):
#   if np.linalg.norm(a_np - z_np[i:1000+i]) == x:
#     print(z_np[i:1000+i])

# Commented out IPython magic to ensure Python compatibility.
# %%time
# da_dist = []
# for i in range(0,9000,1000):
#   da_dist.append(da.linalg.norm(z[i:1000+i]-a))
# da_dist = da.from_array(da_dist)
# x_da = da_dist.min().compute()
# print(x_da)
# for i in range(0,9000,1000):
#   if da.linalg.norm(z[i:1000+i]-a).compute() == x_da:
#     print(z[i:1000+i].compute())

"""4) Определить сколько векторов-столбцов из исходного массива находятся на расстоянии, не превышающем $3|a-v_n|_{L2}$"""

# Commented out IPython magic to ensure Python compatibility.
# %%time
# cnt = 0
# for i in range(0,9000,1000):
#   if np.linalg.norm(a_np-z_np[i:1000+i]) < 3*x:
#     cnt+=1
# print(cnt)

# Commented out IPython magic to ensure Python compatibility.
# %%time
# cnt_da = 0
# for i in range(0,9000,1000):
#   if da.linalg.norm(z[i:1000+i]-a).compute() < 3 * x_da:
#     cnt_da +=1
# print(cnt_da)