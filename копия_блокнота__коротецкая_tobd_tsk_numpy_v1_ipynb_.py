# -*- coding: utf-8 -*-
"""Копия_блокнота__Коротецкая_TOBD_tsk_numpy_v1_ipynb_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EVGFKzon9my7Kun9j0n8GQUguydukXXe

1) Создать в numpy матрицу 11 на 7 вида: [[1, 2, 3, ..., 7], [11, 12, 13, ..., 17], [21, 22, 23, ..., 27], ..., [101, 102, 103, ..., 107]]
"""

import numpy as np

C=np.arange(108)
C[(C % 10 <= 7) & (C % 10 != 0)].reshape(11,7)



"""2) Средствами numpy рассчитать произведения четных чисел от 2 до 20 на ближайшие к ним бОльшие нечетные числа."""

np.linspace(2,20,10)*np.linspace(3,21,10) #если нечетные числа не находятся в пределе до 20

"""3) Приблизительно (с погрешностью порядка 1%) рассчитать на какой части интервала от 0 до 10 значение функции x * sin(x) больше 0.5."""

data = np.vectorize(lambda x: x*np.sin(x))(np.arange(0, 11, 0.01))
t = data > 0.5
print(np.where(t)[0]/100)

"""4) Создать матрицу 8 на 10 из случайных целых (используя модуль numpy.random) чисел из дапозона от 0 до 10 и найти в ней строку (ее индекс и вывести саму строку), в которой сумма значений минимальна."""

A =np.random.randint(0,10,(8, 10))

print(A)
print(A[A.sum(axis=1).argmin()])
print(A.sum(axis=1).argmin())

"""5) Создать две матрицы 30 на 3 из случайных целых чисел из диапазона от 0 до 10 и найти все значения первой матрицы, которые больше соответсвующих (по расположению) значений второй матрицы. Подсчитать сумму этих значений."""

A, B =np.random.randint(0, 10, ( 30, 3)), np.random.randint(0, 10,(30, 3))
#print(A)
#print(B)
np.sum(A[A > B])

"""6) Написать фукнцию, которая для целых значений n и m будет возвращать матрицу размера n на m, имеющую заполнение вида.
Пример для 4 на 4:

0 1 0 1

2 3 2 3

0 1 0 1

2 3 2 3
"""

def matrix(n,m):
    D = np.tile(np.array([[0,1],[2,3]]),(n,m))
    return D[:m,:n]
matrix(4,4)

"""7) Найти все простые числа в пределах ста. (Для решения предлагается использовать Решето Эратосфена) Использовать не более 1 цикла (желательно)."""



def eratosthenes(n):     
    sieve = list(range(n + 1))
    sieve[1] = 0    
    for i in sieve:
        if i > 1:
            for j in range(i + i, len(sieve), i):
                sieve[j] = 0
    sieve1 = [x for x in sieve if x != 0]
    return sieve1


print(eratosthenes(100))

"""8) Задан произвольный массив numpy (например массив из 100 случайных числе от 0 до 1). Необходимо найти в нем число наиболее близкое к заданному."""

A = 0.49
b = np.random.sample(100)
b[np.argmin(np.abs(b - A))]

"""9) При помощи прихотливого индексирования для двухмерного массива размерности (20, 20), состоящего из случайных целых чисел в пределах от 0 до 10 получить массив элементов находящихся на диагонали, проходящей над основной диагональю."""

A =  np.random.randint(low=0, high=10, size=(20, 20))
X = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])
Y = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
A[X,Y]

"""10) Имеется массив из 10 названий городов. При помощи прихотливой индексации сгенерировать последовательность из 100 элементов представляющих случайный выбор из названий городов."""

towns = ['Москва','Волгоград','Тула','Санкт-Петербург','Сочи','Калининград','Тверь','Подольск','Иваново']
t = np.random.choice(towns, size=100)
t

"""11) Решить матричное уравнение `A*X*B=-C` - найти матрицу X. Где `A = [[-1, 2, 4], [-3, 1, 2], [-3, 0, 1]]`, `B=[[3, -1], [2, 1]]`, `C=[[7, 21], [11, 8], [8, 4]]`."""

from numpy import linalg as LA
A = [[-1, 2, 4], [-3, 1, 2], [-3, 0, 1]]
B = [[3, -1], [2, 1]]
#Y = [[7, 21], [11, 8], [8, 4]]
#C = -Y
C = [[-7, -21], [-11, -8], [-8, -4]]

#Матрица X = (-C)*A^(-1)*B^(-1)

print("Финальная матрица X:\n",np.linalg.inv(A)@C@np.linalg.inv(B))

"""12) Проверить, является ли система векторов a1 = (3; −3; 0; 7),
a2 = (2; 2; 4; 7), a3 = (1; 2; 3; 4), a4 = (5; −4; 1; 3) линейно зависимой?
"""

# Для случая вектор a1 - 1 столбец, a2 - 2 и тд

Matrix = [[3, 2, 1, 5],[-3, 2, 2, -4],[0, 4, 3, 1],[7, 7, 4, 3]]
np.linalg.matrix_rank(Matrix) < 4

"""13) Задать два двухмерных массива ar1 и ar2 размерности (4, 7), состоящих из случайных целых чисел в пределах от 0 до 10. Построить двухмерный массив размерности (4, 7), каждый элемент которого представляет собой максиум из двух значений, находящихся на аналогичной позиции в массивах ar1, ar2."""

ar1 = np.random.randint(10, size=(4,7))
ar2 = np.random.randint(10, size=(4,7))
print("Матрица 1:\n",ar1)
print("Матрица 2:\n",ar2)
print("Матрица max:\n",np.maximum(ar1,ar2))

"""14) Задать два двухмерных массива ar1 и ar2 размерности (5, 10), состоящих из случайных целых чисел в пределах от 0 до 10. Удовить все значения ar1 которые совпадают со значениями ar2, расположенными на аналогичных позициях."""

ar1 = np.random.randint(0,10,size=(5,10))
ar2 = np.random.randint(0,10,size=(5,10))

np.where(ar1== ar2,2 * ar1,ar1)

"""15) Заданы три двухмерных массива ar1,ar2 и ar3 размерности (4, 7), состоящих из случайных целых чисел в пределах от 0 до 10. Обнулить все элемены ar1 которые больше соответствующих (находящихся в соответствующих позициях) элементов ar2 и меньше соответствующих элементов ar3."""

ar1 = np.random.randint(0,10,(4,7))
ar2 = np.random.randint(0,10,(4,7))
ar3 = np.random.randint(0,10,(4,7))

ar1 = np.where(ar1 > ar2,0,ar1)
ar1 = np.where(ar1 < ar3,0,ar1)

ar1

"""16) Задан двухмерный массив ar1 размерности (4, 7) состоящий из случайных  чисел в пределах от 0 до 1. Обнулить все значения в массиве, расположенные строго правее и ниже максимального элемента массива. """

ar1 = np.random.rand(4, 7)
A = ar1.flatten()
A[np.argmax(ar1):] = 0
A = A.reshape(ar1.shape)
A